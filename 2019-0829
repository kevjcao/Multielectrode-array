%% Notes
% 1. This code requires sorted spike data from Plexon saved in an excel
% format delineated as: 'SpikeTimes', 'Unit no.', 'Ch. no.'; in that order. 

% 2. It will generate a new array named 'RawUnits' with each unit's firing
% activity listed as a single Nx3 array where N is the no. of events. The
% rasters are created from just the first column of each unit's array (e.g.
% the spike times).



%% Import raw spike sorted data from Plexon 

clear;
close all;

[FileName, FilePath] = uigetfile( ...
       {'*.xlsx','New Excel (*.xlsx)'; ...
       '*.xls','Old Excel (*.xls)';
       '*.txt', 'Text file (*.txt)'}, ...
        'Pick a file', ...
        'MultiSelect', 'on');
File = fullfile(FilePath, FileName);
[num, txt, raw] = xlsread(File);

clearvars txt File


%% Acquire timestamps of light intervals from trigger times
% 1. MC_Rack continuously records the trigger input via a negative (-1) bias voltage every 3 ms
% 2. If a +1V trigger signal is sent via TTL, the bias reaches 0 (or "null") and no time is recorded during this triggering period

Trigger = 1;                                                              % trigger times = 1, other wise = 0

if Trigger > 0           
    [TrigFileName, TrigFilePath] = uigetfile('*.txt');
    trigFile = fullfile(TrigFilePath, TrigFileName);
    fidTrig = fopen(trigFile);

    delimiter = '\t';
    formatSpec = '%*s%s%[^\n\r]';
    TrigTimesArray = textscan(fidTrig, ...                                % opens .txt trigger file (from MC_Rack data tool) and parses raw text file
        formatSpec, 'Delimiter', delimiter, ...                           % into a 1x2 array with 1st cell being 3 ms trigger record
        'TextType', 'string',  'ReturnOnError', false);                   % and 2nd cell being the bias voltage (-1 or null)

    fclose(fidTrig);

    trigTimesRaw = TrigTimesArray{1,1}(:,1);                              % creates new numerical array with only the 3 ms trigger record
    trigTimesRaw(1:4,:) = []; 
    trigTimesRaw = double(trigTimesRaw);
    
    clearvars ans delimiter fidTrig formatSpec TrigTimesArray
    
    parsedTimes = [];

    for i = 1:length(trigTimesRaw)-1                                      % creates an array with the trigger times before and after the 1V TTL signal
        diffTrig = trigTimesRaw(i + 1) - trigTimesRaw(i);
        if diffTrig > 4
            parsedTimes = [parsedTimes; trigTimesRaw(i); trigTimesRaw(i + 1)];
        end
    end
    
    parsedTimes = parsedTimes/1000;
    
    IntervTimes = [parsedTimes(1:2:end,:), parsedTimes(2:2:end,:)];       % splits numTime array into two columns - column 1 for light on and column 2 for light off
else
end


%% Raw histogram of all recorded spikes

Histoplot = 1;                                                            % set 0 (no histogram) or 1 (histogram)
BW = 0.1;                                                                 % set bins (bin width, BW) here (in seconds) 
fprintf('Bin size = %d ms \n', BW * 1000)
spikeTimesHist = cell2mat(raw(:,1));
[N, EDGES] = histcounts(spikeTimesHist, 'BinWidth', BW);                  % N is the counts for each bin; EDGES are the bin edges

hold on;
if Histoplot > 0
    figure(1)
    HistoSpikes = histogram(spikeTimesHist, 'BinWidth', BW);
    xlabel('Time (s)');
    ylabel('Number of spikes');
else
    disp 'No histogram plotted';
end
hold off


%% Raster trains of spike data from all units

Sort = 1;                                                                 % if 1 = sort, if 0 = raw unit # without sorting

[~,~,Ch] = unique(num(:,3));                                              % first separate raw num array based on electrode ch from MEA chip
RawCh = accumarray(Ch, 1:size(num,1),[],@(r){num(r,:)});                  % generate a cell w/ subcells that contain each channel's unit firing

RawUnits = [];
ntrials = [];
spikeTimes = [];

for i = 1:numel(RawCh)
    [~,~,Units] = unique(RawCh{i,1}(:,2));                                % generate RawCh array based on unit number from each ch
    RawUnits = [RawUnits; ...
        accumarray(Units, ...
        1:size(RawCh{i,1}(:,2),1),[],@(r){RawCh{i,1}(r,:)})];             % generate a cell array with subcells that has each unit's activity
end

figure(2)
hold on;

if Sort < 1
    for m = 1:length(RawUnits)
        spikeTimes = RawUnits{m}(:,1);
        ntrials = ones(size(spikeTimes,1),1) * m;
        plot(spikeTimes, ntrials, 'Marker', '.', 'Color', 'k', 'LineStyle', 'none')
    end
else
end

if Sort > 0
    [~,Sorted] = sort(cellfun(@length,RawUnits), 'descend');
    RawUnits = RawUnits(Sorted);
    for m = 1:length(RawUnits)
        spikeTimes = RawUnits{m}(:,1);
        ntrials = ones(size(spikeTimes,1),1) * m;
        plot(spikeTimes, ntrials, 'Marker', '.', 'Color', 'k', 'LineStyle', 'none')
    end
else
end

ylim([0 size(RawUnits,1) + 1]);
xlabel('Time (s)');
ylabel('Unit');
hold off

fprintf('Number of units = %o \n', m);


%% Calculating firing frequencies & creating frequency raster

avgFiring = (N(1,:) / BW) / numel(RawUnits);                              % [no. events / bin size (s) = frequency] / no. units = average firing frequency per unit
BinCenters = EDGES(1:end-1) + diff(EDGES)/2;

figure(3)
FreqPlot = bar(BinCenters, avgFiring, 'FaceColor', 'k', 'BarWidth', 1.5);

if Trigger > 0
    hold on;
    for j = 1:length(IntervTimes)                                         % creates a shaded region for the light intervals
        stimLim = IntervTimes(j,:);
        lightStim = [min(stimLim) max(stimLim) max(stimLim) min(stimLim)];
        patch(lightStim, [0 0 max(ylim)*[1 1]], [0.3010 0.7450 0.9330], 'LineStyle', 'none');
        hold on
    end

    FreqPlot = bar(BinCenters, avgFiring, 'FaceColor', 'k', 'BarWidth', 1.5);
    hold on
else
end

xlabel('Time (s)');
ylabel('Average firing frequency per unit (Hz)');

hold off


%% Photoswitch index (e.g. relative change in RGC firing in dark v. in light)
% Calculates average firing frequencies in darkness & in light, and the
% average PI from these two values. To do so the code first calculates 1.
% the total frequency (sum) of light responses and 2. the total
% number of these events. The average light freq is the ratio of these two
% values (sum of lightOn / total no. light events). 
% The dark frequency is calculated by taking the total frequency of the
% entire recording and subtracting the total frequency of the light
% responses. The total number of dark events is calulated the same way.

if Trigger > 0
    lightOn = [];
    lightEvents = [];

    for j = 1:length(IntervTimes(:,1))
        lightOn = [lightOn; sum(avgFiring(BinCenters.' >= IntervTimes(j,1) & BinCenters.' <= IntervTimes(j,2)))];
        lightEvents = [lightEvents; numel(avgFiring(BinCenters.' >= IntervTimes(j,1) & BinCenters.' <= IntervTimes(j,2)))];
    end

    lightOff = (sum(avgFiring(BinCenters.' >= 0)) - sum(lightOn));
    darkEvents = (numel(avgFiring(BinCenters.' >= 0)) - sum(lightEvents));

    avgDarkFirFreq = lightOff/darkEvents;
    avgLightFirFreq = sum(lightOn)/sum(lightEvents);
    avgPI = ((avgLightFirFreq - avgDarkFirFreq) / (avgLightFirFreq + avgDarkFirFreq));

    fprintf('Average firing frequency in darkness = %.2f Hz \n', avgDarkFirFreq);
    fprintf('Average firing frequency in light = %.2f Hz \n', avgLightFirFreq);
    fprintf('Average photoswitch index, P.I. = %.3f \n', avgPI);
else
end


%% Calculate dark firing
% If there is no trigger, this sequence calculates the total firing
% frequency without light stimulus ("dark firing").

if Trigger < 1
    lightOff = sum(avgFiring(BinCenters.' >= 0));
    darkEvents = numel(avgFiring(BinCenters.' >= 0));
    
    avgDarkFirFreq = lightOff/darkEvents;
    
    fprintf('Average firing frequency in darkness = %.2f Hz \n', avgDarkFirFreq);
else
end


%% Subplot figure
figure(5)

ax(1) = subplot(2,1,1);

if Sort < 1
    for m = 1:length(RawUnits)
        hold on;
        spikeTimes = RawUnits{m}(:,1);
        ntrials = ones(size(spikeTimes,1),1) * m;
        plot(spikeTimes, ntrials, 'Marker', '.', 'Color', 'k', 'LineStyle', 'none')
    end
    hold off;
else
end

if Sort > 0
    [~,Sorted] = sort(cellfun(@length,RawUnits), 'descend');
    RawUnits = RawUnits(Sorted);
    for m = 1:length(RawUnits)
        hold on;
        spikeTimes = RawUnits{m}(:,1);
        ntrials = ones(size(spikeTimes,1),1) * m;
        plot(spikeTimes, ntrials, 'Marker', '.', 'Color', 'k', 'LineStyle', 'none')
    end
    hold off;
else
end

ylim([0 size(RawUnits,1) + 1]);
ylabel('Unit');
hold off;

ax(2) = subplot(2,1,2);

FreqPlot = bar(BinCenters, avgFiring, 'FaceColor', 'k', 'BarWidth', 1.5);

if Trigger > 0
    hold on;
    for j = 1:length(IntervTimes)                                         
        stimLim = IntervTimes(j,:);
        lightStim = [min(stimLim) max(stimLim) max(stimLim) min(stimLim)];
        patch(lightStim, [0 0 max(ylim)*[1 1]], [0.3010 0.7450 0.9330], 'LineStyle', 'none');
        hold on
    end

    FreqPlot = bar(BinCenters, avgFiring, 'FaceColor', 'k', 'BarWidth', 1.5);
    hold on
else
end

xlabel('Time (s)');
ylabel('Average firing frequency per unit (Hz)');
hold off

linkaxes(ax,'x');                                                         % links the two x-axes 


%% Determine photoswitch index per unit

% if Trigger > 0

% lightOnUnit = [];
% lightEventsUnit = [];

% for j = 1:length(IntervTimes(:,1))
    % for n = 1:length(RawUnits)
        % lightOnUnit = [lightOnUnit; sum(RawUnits{n,1}(:,1) >= IntervTimes(j,1) & RawUnits{n,1}(:,1) <= IntervTimes(j,2))];
        % lightEventsUnit = [lightEventsUnit; numel(RawUnits{n,1}(:,1) >= IntervTimes(j,1) & RawUnits{n,1}(:,1) <= IntervTimes(j,2))];
    % end
% end

